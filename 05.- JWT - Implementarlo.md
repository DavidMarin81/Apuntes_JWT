# Implementaci칩n de JWT
## 쯈u칠 es JWT y para qu칠 sirve?
- JWT (Jason Web Token)
- Es un token seguro que se usa para autenticar usuarios sin necesidad de guardar sesi칩n en el servido
- Est치 formado por tres partes en Base64:
    ~~~css
    HEADER.PAYLOAD.SIGNATURE
    ~~~
    - `Header`: indica el algoritmo de firma, por ejemplo `HS256`
    - `Payload`: contiene la informaci칩n que quieres incluir, como `userId`, `email`, `rol`
    - `Signature`: es la firma que asegura que el token no fue modificado. Se genera con la clave secreta que definiste en `appsettings.json`
    - Ejemplo:
        ~~~json
        {
            "nameid": "1",
            "email": "david@david.com",
            "role": "standard",
            "exp": 1735459200
        }
        ~~~ 
        - `exp`: indica la fecha de expiraci칩n del token
        - Con este token, cualquier petici칩n futura puede demostrar que viene de un usuario autenticado

## C칩mo se integra JWT en la arquitectura
- Controller (`AuthController`): recibe la solicitud del login
- Service (`AuthService`): valida credenciales y genera el token JWT
- Repository (`UserRepository`): obtiene la informaci칩n del usuario de la base de datos
- Cliente (`React`): recibe el token y lo almacena (generalmente en `localStorage` o `sessionStorage`)

## Para proteger endpoints
- En `Program.cs` configuraste JWT con `AddAuthentication` y `AddJwtBearer`
- Cuando un cliente hace una petici칩n con `Authorization: Bearer <token>` ASP.NET Core valida autom치ticamente:
    - Firma correcta
    - Token no expirado
    - Issuer y Audience correctos
- Si todo es v치lido, en tus controladores puedes usar `[Authorize]` para exigir autenticaci칩n

## C칩mo usar roles
- En el token ya se guarda el rol del usuario
    ~~~csharp
    new Claim(ClaimTypes.Role, user.Role!.Name)
    ~~~
- En los endpoints puedes restringir por rol
    ~~~csharp
    [Authorize(Roles = "master")]
    [HttpGet("admin-data")]
    public IActionResult GetAdminData()
    {
        return Ok("Esto solo lo ve un master");
    }
    ~~~
- Si el usuario tiene rol diferente, ASP.NET Core devuelve 401 o 403 autom치ticamente

## Configurar JWT
- Instalar el paquete NuGet correcto
    ~~~powershell
    Install-Package Microsoft.AspNetCore.Authentication.JwtBearer -Version 8.0.10
    ~~~
- Configurar JWT en `Program.cs`
    ~~~csharp
    builder.Services.AddAuthentication(options =>
    {
        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
        options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
    })
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new Microsoft.IdentityModel.Tokens.SymmetricSecurityKey(key)
        };
    });
    ~~~
    - Esto dice a ASP.NET Core c칩mo validar los tokens entrantes
- A침adir los middlewares en el orden correcto
    - En `Program.cs`, en tu pipelinet (app.Use...), debes poner `UseAuthentication()` antes de `UseAuthorization()`
        ~~~csharp
        app.UseHttpsRedirection();

        app.UseAuthentication(); // 丘멆잺 Muy importante que vaya antes de UseAuthorization
        app.UseAuthorization();
        ~~~
- Con esto, el backend ya entiende los JWT y los controladores pueden usar `[Authorize]` o `[Authorize(Roles = "master")]`

## Crear un endpoint protegido
- Vamos a a침adir un controlador nuevo o usar uno existente (por ejemplo `AuthController`) pero esta vez con `[Authorize]`
    ~~~csharp
    // Este endpoint solo se puede acceder si env칤as un token JWT v치lido
    [HttpGet("protected")]
    [Authorize] // 游 Este endpoint requiere JWT
    public IActionResult ProtectedEndpoint()
    {
        var email = User.FindFirst(System.Security.Claims.ClaimTypes.Email)?.Value;
        var role = User.FindFirst(System.Security.Claims.ClaimTypes.Role)?.Value;

        return Ok(new { message = "Acceso concedido", email, role });
    }
    ~~~
- Para probarlo en Swagger
    - Primero, haz login usando el endpoint `/api/auth/login` y copia el token que devuelve
    - Segundo, en Swagger:
        - Dale al bot칩n `Authorize` (arriba a la derecha, 游)
        - Pega el token as칤
            ~~~js
            Bearer TU_TOKEN_AQUI
            ~~~
            - Importante escribir la palabra `Bearer` seguida de un espacio y luego el token
    - Ahora prueba `/api/Auth/protected
        - Si todo est치 bien, deber칤a devolver `Acceso concedido` con tu email y rol
        - Si no env칤as token o es inv치lido, devolver치 `401 Unauthorized`

## Para usarlo con Swagger
- Agregar la configuraci칩n de JWT en Swagger
    ~~~csharp
    // Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
    builder.Services.AddEndpointsApiExplorer();
    // Con esto, podemos usar JWT con Swagger
    // A침adimos JWT para Swagger
    builder.Services.AddSwaggerGen(c =>
    {
        c.SwaggerDoc("v1", new OpenApiInfo
        {
            Title = "Prueba02JWT API",
            Version = "v1"
        });

        // A침adimos JWT Bearer como esquema de seguridad
        c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
        {
            Name = "Authorization",
            Type = SecuritySchemeType.Http,
            Scheme = "Bearer",
            BearerFormat = "JWT",
            In = ParameterLocation.Header,
            Description = "Ingresa 'Bearer' seguido de tu token JWT"
        });

        c.AddSecurityRequirement(new OpenApiSecurityRequirement
        {
            {
                new OpenApiSecurityScheme
                {
                    Reference = new OpenApiReference
                    {
                        Type = ReferenceType.SecurityScheme,
                        Id = "Bearer"
                    }
                },
                new string[]{}
            }
        });
    });
    ~~~

## Qu칠 hace `[Authorize]` en el controlador
- Es un atributo de ASP.NET Core que se usa en controladores o acciones para protegerlos con autenticaci칩n
    - Cuando pones `[Authorize]` en un controlador, todas las acciones dentro de ese controlador requerir치n que el usuario est칠 autenticado
    - Cuando lo pones en una acci칩n concreta, solo esa acci칩n requiere autenticaci칩n
- En otras palabras, bloquea el acceso a usuarios que no tengan un token v치lido o sesi칩n v치lida

## C칩mo sabe `[Authorize]` qui칠n eres
- Cuando env칤as un JWT v치lido en el header de la petici칩n
    ~~~css
    Authorization: Bearer <tu_token_aqu칤>
    ~~~
    - ASP.NET Core hace lo siguiente internamente:
        - El middleware de autenticaci칩n JWT intercepta la petici칩n (`app.UseAuthentication()` en `Program.cs`)
        - Toma el token del header `Authorization`
        - Valida:
            - La firma del token (usando la clave secreta `JWT:Key`)
            - El `issuer` y el `audience` (los valores que pusiste en `appsettings.json`)
            - La fecha de expiraci칩n
        - Si todo es correcto, crea un objeto `ClaimsPrincipal` que representa al usuario autenticado
        - `[Authorize]` comprueba que s칤 existe un usuario autenticado (`HttpContext.user` no es nulo y est치 validado)
            - Si no existe -> 401 Unauthorized
            - Si existe -> permite continuar

## Roles y permisos con `[Authorize]`
- Puedes a침adir restricciones por roles usando la propiedad `Roles`
    ~~~csharp
    [Authorize(Roles = "master")]
    public IActionResult OnlyMasters()
    {
        return Ok("Solo usuarios master pueden acceder");
    }
    ~~~
- O varios roles
    ~~~csharp
    [Authorize(Roles = "master,intranet")]
    public IActionResult MastersOrIntranet()
    {
        return Ok("Usuarios master o intranet pueden acceder");
    }
    ~~~
- ASP.NET Core compara los claims del token (`ClaimTypes.Role`) con los roles que indicaste

## Claims del usuario
- Dentro de tu acci칩n puedes acceder a la informaci칩n del usuario usando `User`:
    ~~~csharp
    var email = User.FindFirst(System.Security.Claims.ClaimTypes.Email)?.Value;
    var role = User.FindFirst(System.Security.Claims.ClaimTypes.Role)?.Value;
    var userId = User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
    ~~~
- Esto es gracias a que cuando creaste el JWT en `AuthService.LoginAsync`, pusiste estos claims:
    ~~~csharp
    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
    new Claim(ClaimTypes.Email, user.Email),
    new Claim(ClaimTypes.Role, user.Role!.Name)
    ~~~
- Resumen visual del flujo
    - Cliente hace petici칩n -> `[Authorize]` en el endpoint
    - Middleware JWT revisa token:
        - V치lido -> genera `ClaimsPrincipal`
        - Inv치lido -> 401 Unauthorized
    - `[Authorize]` revisa que `HttpContext.User.Identity.IsAuthenticated == true`
    - Si todo ok -> endpoint se ejecuta




