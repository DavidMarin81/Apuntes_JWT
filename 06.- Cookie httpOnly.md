# Cookie httpOnly
## ¿Qué es una cookie `httpOnly`?
- Una cookie es un pequeño archivo que el navegador guarda y envía automáticamente con cada petición al mismo dominio
- Una cookie `httpOnly` es una cookie que no puede ser accedida por JavaScript en el frontend `(document.cookie)`
- Esto significa que aunque abra la consola (F12) o inyecte scripts maliciosos, no puede robar el contenido de la cookie
- Esto la hace ideal para almacenar tokens JWT de forma segura

## ¿Cómo se usa con JWT?
- Flujo típico:
    - El usuario hace login y envía `email` + `password`
    - El backend valida las credenciales
    - El backend genera un JWT y lo envía en la respuesta dentro de una cookie `httpOnly`
        ~~~csharp
        var token = tokenHandler.WriteToken(jwtToken);

        var cookieOptions = new CookieOptions
        {
            HttpOnly = true,      // No accesible por JS
            Secure = true,        // Solo HTTPS
            SameSite = SameSiteMode.Strict, // Evita envío en terceros sitios
            Expires = DateTime.UtcNow.AddMinutes(30)
        };

        Response.Cookies.Append("jwt", token, cookieOptions);
        ~~~
    - Cada ver que el frontend hace peticiones al backend, el navegador envía automáticamente esta cookie

## Validación en el backend
- En tu middleware JWT (`AddJWTBearer`), puedes configurar para que lea la cookie:
    ~~~csharp
    options.Events = new JwtBearerEvents
    {
        OnMessageReceived = context =>
        {
            if (context.Request.Cookies.ContainsKey("jwt"))
            {
                context.Token = context.Request.Cookies["jwt"];
            }
            return Task.CompletedTask;
        }
    };
    ~~~
- Así, no necesitas que el frontend mande el token explícitamente en headers
- El backend valida el token normalmente: expiración, firma y claims

## Ventajas de usar `httpOnly`
|Ventaja|Explicación|
|---|---|
|Más seguro | JS no puede acceder a la cookie, evita robo de tokens vía XSS| 
|Transparente | El navegador envía la cookie automáticamente en cada request |
| Fácil de invalidar | Puedes eliminarla con `Response.Cookies.Delete("jwt")` en logout|

## ¿Qué códigos HTTP devuelve JWT?
|codigo | Tipo | Explicacion |
|-|-|-|
| 200 | OK | Acceso permitido |
| 401 | Unauthorized | No autorizado (el token no es válido no existe)|
| 403 | Forbidden | Prohibido (el token es válido pero el usuario no tiene permisos para ese recurso)

## Configurar el login para enviar la cookie HttpOnly
- En el `AuthController`, cuando haces el login y generas el token, en lugar de devolverlo en JSON, lo puedes poner en una cookie:
    ~~~csharp
    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginDto dto)
    {
        var token = await _authService.LoginAsync(dto);
        if (token == null)
            return Unauthorized(new { message = "Credenciales incorrectas." });

        // Configurar cookie HttpOnly
        Response.Cookies.Append("jwt", token, new CookieOptions
        {
            HttpOnly = true,
            Secure = true,      // solo HTTPS
            SameSite = SameSiteMode.Strict, // opcional según tu escenario
            Expires = DateTime.UtcNow.AddMinutes(60)
        });

        return Ok(new { message = "Login correcto" });
    }
    ~~~
- `HttpOnly = true` hace que JavaScript no pueda leer la cookie
- `Secure = true` solo permite que la cookie se envíe por HTTPS
- `SameSite` protege contra CSRF

## Configurar el Middleware de autentiación
- Asegúrate de que ASP.NET Core pueda leer el token de la cookie
    ~~~csharp
    builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Events = new JwtBearerEvents
        {
            OnMessageReceived = context =>
            {
                // Leer token desde cookie "jwt"
                if (context.Request.Cookies.ContainsKey("jwt"))
                {
                    context.Token = context.Request.Cookies["jwt"];
                }
                return Task.CompletedTask;
            }
        };

        options.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new Microsoft.IdentityModel.Tokens.SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))
        };
    });
    ~~~
- Con esto, cada request que llegue con la cookie `jwt` será autenticado automáticamente.
- No necesitas enviarlo manualmente desde el frontend

## Cambios en el Frontend
- Con `httpOnly`, JavaScript no puede acceder al token, por lo que tu frontend ya no necesita guardar el JWT en `localStorage`. Solo envía las peticiones normales al backend y la cookie se manda automáticamente.
    ~~~js
    fetch("https://localhost:7058/api/Auth/protected", {
        method: "GET",
        credentials: "include" // esto hace que la cookie se envíe
    })
    .then(res => res.json())
    .then(data => console.log(data));
    ~~~
- `credentials: "include"` es clave para enviar cookies en CORS
- No podrás hacer `parseJWT` en el frontend porque no tienes acceso al token

## Logout
- Para cerrar sesión, simplemente eliminas la cookie desde el backend
    ~~~csharp
    [HttpPost("logout")]
    public IActionResult Logout()
    {
        Response.Cookies.Delete("jwt");
        return Ok(new { message = "Sesión cerrada" });
    }
    ~~~

## ¿Qué se consigue con esto?
- JWT nunca se expone a JavaScript
- Seguidad frente a XSS
- El backend sigue validando token automáticamente
- No necesitas manipular `localStorage` ni `sessionStorage`