# Creación de aplicación completa (Backend y Frontend) con JWT

## RESUMEN DEL CONTENIDO
- LoginPage.jsx
    - Formulario de login
    - Petición al backend (`axios .post`) para obtener el JWT
    - Guardado del token en `localStorage`
    - Redirección según el rol (`/admin` o `/user`)
- PrivateRoute.jsx
    - Protege rutas según el rol
    - Decodifica el JWT del `localStorage`
    - Redirige a `/login` si el token no existe, es inválido o el rol no coincide
- App.jsx
    - Configura React Router
    - Define rutas públicas (`/login`) y privadas (`/admin` y `/user`)


## Preparar el entorno
- Crear el proyecto React (Frontend)
    ~~~bash
    npm create vite@latest "nombreDelProyecto"
    ~~~ 
- Elegir React y JavaScript
- Una vez creado, entrar en la carpeta del proyecto
    ~~~bash
    npm install
    npm run dev
    ~~~
- Esto levanta un servidor de desarrollo en "http://localhost:XXXX"

## Configurar React Router y PrivateRouter
- Objetivo
    - Permite que tu aplicación tenga múltipoles páginas (login, admin, user) sin recargar la página
    - Proteger rutas según el rol del usuario, usando el JWT que obtienes al iniciar sesión
- En app.jsx: definir las rutas
    ~~~js
    import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
    import LoginPage from "./LoginPage";
    import AdminPage from "./AdminPage";
    import UserPage from "./UserPage";
    import PrivateRoute from "./PrivateRoute";

    export default function App() {
        return (
            <BrowserRouter>
                <Routes>
                    <Route path="/" element={<Navigate to="/login" />} />
                    <Route path="/login" element={<LoginPage />} />

                    <Route
                        path="/admin"
                        element={
                            <PrivateRoute role="admin">
                                <AdminPage />
                            </PrivateRoute>
                        }
                    />

                    <Route
                        path="/user"
                        element={
                            <PrivateRoute role="user">
                                <UserPage />
                            </PrivateRoute>
                        }
                    />
                </Routes>
            </BrowserRouter>
        );
    }
    ~~~
    - Desglose
        - BrowserRouter
            - Es el componente que envuelve toda la app y permite usar rutas como URL "normales" (no hash #)
            - Debe estar en el nivel más alto, normalmente en App.jsx
        - Routes
            - Contiene todas las rutas de tu aplicación
            - Cada Route representa una página o ruta específica
        - Ruta:
            ~~~js
            Route path="/" element={<Navigate to ="/login" />}
            ~~~
            - Si alguien entra a la raíz (/), automáticamente se redirige a "/login"
            - Navigate funciona como Redirect
        - Ruta:
            ~~~js
            Route path="/login" element={<LoginPage />}
            ~~~
            - Ruta pública donde cualquier usuario puede acceder para iniciar sesión
        - Rutas protegidas (/admin y /user)
            ~~~js
            <Route
                path="/admin"
                element={
                    <PrivateRoute role="admin">
                        <AdminPage />
                    </PrivateRoute>
                }
            />
            ~~~
            - Aquí no renderizamos "AdminPage" directamente
            - Envolvemos "AdminPage" dentro de "PrivateRoute"
            - "PrivateRoute" verifica si hay un token válido y si el rol coincide
            - Si el token es inválido o el rol no coincide, redirige a "/login"

- PrivateRoute.jsx: proteger rutas
    ~~~js
    import { Navigate } from "react-router-dom";

    export default function PrivateRoute({ children, role }) {
        const token = localStorage.getItem("token");

        if (!token) return <Navigate to="/login" />;

        try {
            const payload = JSON.parse(atob(token.split(".")[1]));
            const userRole = payload["http://schemas.microsoft.com/ws/2008/06/identity/claims/role"];

            if (role && userRole !== role) return <Navigate to="/login" />;

            return children;
        } catch (err) {
            console.error("Error al decodificar JWT:", err);
            return <Navigate to="/login" />;
        }
    }
    ~~~
    - Desglose
        - Recoger el token del "localStorage"
            ~~~js
            const token = localStorage.getItem("token");
            ~~~
            - Si no existe, significa que el usuario  no está logeado y redirige a "/login"
        - Decodificar el JWT
            ~~~js
            const payload = JSON.parse(atob(token.split(".")[1]));
            ~~~
            - Los JWT tienen tres partes: header.payload.signature
            - "payload" contiene los datos del usuario, incluyendo el rol
            - "atob" convierte de Base64  a texto plano
            - "JSON.parse" convierte la cadena a objeto JS
        - Leer el rol
            ~~~js
            const userRole = payload["http://schemas.microsoft.com/ws/2008/06/identity/claims/role"];
            ~~~
            - JWT de tu backend guarda el rol de usuario en esta claim
        - Comparar el rol de la ruta y el rol de usuario
            ~~~js
            if (role && userRole !== role) return <Navigate to="/login" />;
            ~~~
            - Si la ruta requiere un rol (role) y el usuario no coincide => redirige a "/login"
        - Renderizar la página protegida
            ~~~js
            return children;
            ~~~
            - Si todo está correcto, se renderiza el componente que envolvimos (AdminPage o UserPage)
        - children
            - Es cualquier contenido que pongas entre las etiquetas de un componente (h1, p, `<AdminPage>`)
            - En `PrivateRoute` funciona como un envoltorio que protege cualquier componente hijo
            - `PrivateRoute` decide si renderiza ese hijo o redirige al login según el token y el rol
        - payload
            - Se splitea y se obtiene la segunda parte del token
            - Son los datos que queremos enviar (usuario, rol, ID, ...)
            - En vez de ver "role": "user" verás:
                ~~~json
                {
                    "http://schemas.microsoft.com/ws/2008/06/identity/claims/role": "user",
                    ...
                }
                ~~~
                - Hay que usar el URI completo como key porque así es como .NET lo genera
            
    - Resumen conceptual
        - App.jsx define qué rutas existen
        - PrivateRoute.jsx verifica quién puede acceder
        - Esto permite:
            - Redirigir usuarios no logueados
            - Restringir acceso según rol (admin/user)

- Proteger rutas con PrivateRoute (Repaso)
    - Ahora que ya sabemos cómo decodificar el JWT y obtener el rol, necesitamos asegurarnos de que solo los usuarios autorizados puedan acceder a ciertas páginas
    - Se hace con un componente llamado `PrivateRoute`
    - ¿Qué hace `PrivateRoute`?
        - Es un componente envoltorio (wrapper) que:
            - Comprueba si hay un token en `localStorage`
                - Si no hay token => redirige a `/login`
            - Decodifica el token y extrae el rol de usuario
            - Compara el rol requerido (`role`pasado como prop) con el rol del usuario
                - Si no coincide => redirige a `/login`
            - Si todo es correcto => renderiza el componente hijo (`children`)
        ~~~js
        export default function PrivateRoute({ children, role }) {
            const token = localStorage.getItem("token");

            if (!token) return <Navigate to="/login" />;

            try {
                const payload = JSON.parse(atob(token.split(".")[1]));
                const userRole = payload["http://schemas.microsoft.com/ws/2008/06/identity/claims/role"];

                if (role && userRole !== role) return <Navigate to="/login" />;

                return children;
            } catch (err) {
                console.error("Error al decodificar JWT:", err);
                return <Navigate to="/login" />;
            }
        }
        ~~~

## Configurar `App.jsx` con las rutas protegidas
- Ahora que ya tenemos nuestro `PrivateRoute`, vamos a decirle a React Router qué páginas mostrar según el rol de usuario
- Importaciones necesarias
    - En `App.jsx` necesitamos:
        ~~~js
        import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
        import LoginPage from "./LoginPage";
        import AdminPage from "./AdminPage";
        import UserPage from "./UserPage";
        import PrivateRoute from "./PrivateRoute";
        ~~~
        - `BrowserRouter`: envuelve toda la app para permitir rutas
        - `Routes` y `Route`: definen cada ruta de nuestra aplicación
        - `Navigate`: permite redirigir
        - Los componentes de página (`LoginPage`, `AdminPage`, `UserPage`)
        - Nuestro componente `PrivateRoute` para proteger rutas

- Configurar rutas públicas y privadas
    ~~~js
    <BrowserRouter>
        <Routes>
            {/* Ruta raíz: redirige al login */}
            <Route path="/" element={<Navigate to="/login" />} />

            {/* Ruta pública de login */}
            <Route path="/login" element={<LoginPage />} />

            {/* Ruta privada para admin */}
            <Route
            path="/admin"
            element={
                <PrivateRoute role="admin">
                <AdminPage />
                </PrivateRoute>
            }
            />

            {/* Ruta privada para user */}
            <Route
            path="/user"
            element={
                <PrivateRoute role="user">
                <UserPage />
                </PrivateRoute>
            }
            />
        </Routes>
    </BrowserRouter>
    ~~~
    - Ruta raíz `/`: redirige al login
    - Ruta `/login`: cualquiera puede acceder
    - Ruta `/admin`: solo accesible si el usuario tiene rol `admin`
    - Ruta `/user`: solo accesible si el usuario tiene rol `user`
        - Si el usuario intenta acceder a `/admin` o `/user` sin token o con rol incorrecto, `PrivateRoute` lo redirige a `/login`
- Resumen
    - `App.jsx`: define la navegación de toda la app
    - Las rutas privadas se protegen usando `PrivateRoute`
    - Las rutas públicas (login) pueden ser accedidas sin token
    - Redirigimos automáticamente según el rol para que el flujo sea seguro

## Crear ´LoginPage.jsx` y conectar con el Backend
- El objetivo de este paso es:
    - Permitir al usuaruio ingresar `username` y `password`
    - Hacer una petición al backend para validar las credenciales
    - Guardar el JWT en `localStorage`
    - Redirigir al usuario según su rol
- Importaciones necesarias
    ~~~js
    import { useState } from "react";
    import axios from "axios";
    import { useNavigate } from "react-router-dom";
    ~~~
    - `useState`: para manejar el estado de los inputs
    - `axios`: para hacer peticiones HTTP al backend
    - `useNavigate`: para redirigir programáticamente según rol
- Estado de los inputs
    ~~~js
    const [username, setUsername] = useState("");
    const [password, setPassword] = useState("");
    const navigate = useNavigate();
    ~~~
    - `useName` y `password` se actualizan al escribir en los inputs
    - `navigate` nos permite cambiar de página
- Función ´handlerLogin`
    ~~~js
    const handleLogin = async (e) => {
        e.preventDefault();

        try {
            // 1️⃣ Hacemos la petición al backend
                const res = await fetch("https://localhost:7295/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({ username, password }),
            });

            // 2️⃣ Guardamos el token en localStorage
            if (!res.ok) throw new Error("Usuario o contraseña incorrectos");

            const data = await res.json();
            const token = data.token;
            localStorage.setItem("token", token);

            // 3️⃣ Decodificamos el token para obtener el rol
            const payload = JSON.parse(atob(token.split(".")[1]));
            const role = payload["http://schemas.microsoft.com/ws/2008/06/identity/claims/role"];

            // 4️⃣ Redirigimos según el rol
            if (role === "admin") navigate("/admin");
            else navigate("/user");

        } catch (err) {
            console.error("Error en login:", err);
            alert("Usuario o contraseña incorrectos");
        }
    };
    ~~~
    - `const res = await fetch("https://localhost:7295/api/auth/login", {`: manda el username y password al endpoint `/api/auth/login`
    - `localStorage.setItem("token", token)`: guarda el JWT para usarlo después
    - `JSON.parse(atob(token.split[1]))`: decodifica la parte del payload del JWT
    - Extraemos el rol usando
        ~~~js
        payload["http://schemas.microsoft.com/ws/2008/06/identity/claims/role"];
        ~~~
    - Redirigimos según el rol (`/admin` o `/user`)
- Formulario de login
    ~~~js
    <form onSubmit={handleLogin} style={{ textAlign: "center", marginTop: "2rem" }}>
        <input
            placeholder="Username"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            autoComplete="username"
        />
        <input
            placeholder="Password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            autoComplete="current-password"
        />
        <button type="submit">Login</button>
    </form>
    ~~~ 
    - `onSubmit={handleLogin}`: evita que la página se recargue y ejecuta la función
    - `autocomplete`: recomendado para los inputs de usuario y contraseña
- Resumen del flujo
    - El usuario escribe username y password
    - Al pulsar `Login`, se hace la petición al backend
    - Si es válido:
        - Se guarda el token
        - Se decodifica para obtener el rol
        - Se redirige a la ruta correspondiente (`/admin` o `/user`)
    - Si falla:
        - Se muestra un error (`alert`)
