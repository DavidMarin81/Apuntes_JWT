# Repository
## ¿Qué es el Repository en C#?
- Un **Repository** es un patrón de diseño que actúa como una capa intermedia entre la base de datos y la lógica de negocio
- Su objetivo principal es **encapsular el acceso a los datos**, de forma que el resto de la aplicación no sepa si esos datos vienen de:   
    - Una base de datos SQL
    - Un archivo JSON
    - Una API externa
    - O incluso datos en memoria para pruebas

## Objetivo principal
- "Separar la lógica de negocio del código que accede a los datos"
- De esa forma, si mañana cambias de base de datos, el resto del código no se toca
- Solo cambia la implementación del repositorio

## Estructura básica
- Normalmete en C# lo verás dividido así
    - Repositories
        - IUserRepository.cs
        - UserRepository.cs

## La implementación (UserRepository)
- El **Repository** se encarga de acceder a los datos
- Su responsabilidad es obtener, insertar, modificar o eliminar información, sin lógica de negocio
- Podemos hacer un ejemplo en memoria para entender la idea
    - `User.cs`(modelo)

        ~~~csharp
        namespace MyApp.Models
        {
            public class User
            {
                public int Id { get; set; }
                public string Name { get; set; } = string.Empty;
                public string Email { get; set; } = string.Empty;
            }
        }
        ~~~

    - `IUserRepository.cs` (interfaz)

        ~~~csharp
        using MyApp.Models;

        namespace MyApp.Repositories
        {
            public interface IUserRepository
            {
                Task<IEnumerable<User>> GetAllAsync();
                Task<User?> GetByIdAsync(int id);
                Task<bool> AddAsync(User user);
                Task<bool> UpdateAsync(User user);
                Task<bool> DeleteAsync(int id);
            }
        }
        ~~~
    
    - `UserRepository.cs` (implementación)
        ~~~csharp
        using MyApp.Models;

        namespace MyApp.Repositories
        {
            public class UserRepository : IUserRepository
            {
                private readonly List<User> _users = new()
                {
                    new User { Id = 1, Name = "Ana", Email = "ana@example.com" },
                    new User { Id = 2, Name = "Luis", Email = "luis@example.com" }
                };

                public Task<IEnumerable<User>> GetAllAsync()
                {
                    return Task.FromResult<IEnumerable<User>>(_users);
                }

                public Task<User?> GetByIdAsync(int id)
                {
                    var user = _users.FirstOrDefault(u => u.Id == id);
                    return Task.FromResult(user);
                }

                public Task<bool> AddAsync(User user)
                {
                    user.Id = _users.Max(u => u.Id) + 1;
                    _users.Add(user);
                    return Task.FromResult(true);
                }

                public Task<bool> UpdateAsync(User user)
                {
                    var existing = _users.FirstOrDefault(u => u.Id == user.Id);
                    if (existing == null)
                        return Task.FromResult(false);

                    existing.Name = user.Name;
                    existing.Email = user.Email;
                    return Task.FromResult(true);
                }

                public Task<bool> DeleteAsync(int id)
                {
                    var user = _users.FirstOrDefault(u => u.Id == id);
                    if (user == null)
                        return Task.FromResult(false);

                    _users.Remove(user);
                    return Task.FromResult(true);
                }
            }
        }
        ~~~
- Claves para entenderlo bien
    - No hay SQL ni base de datos real
        - Todo se hace sobre una lista interna `_users`
        - Así puedes aprender la estructura sin depender de un motor
    - Métodos asíncronos ( `Task<T>`)
        - Se usan porque en una implementación real (con base de datos), las operaciones serán asíncronas
        - Así luego puedes cambiar la fuente de datos sin tocar el resto del código
    - El repositorio NO toma decisiones de negocio
        - Solo "trae o guarda datos"
        - Por ejemplo: validar que un email  no se repita, eso le corresponde al *Service*

- Cómo se usa
    - En otro lugar, usarías el repositorio así
        ~~~csharp
        var repo = new UserRepository();

        // Obtener todos
        var users = await repo.GetAllAsync();

        // Agregar uno nuevo
        await repo.AddAsync(new User { Name = "Carla", Email = "carla@example.com" });

        // Actualizar
        await repo.UpdateAsync(new User { Id = 2, Name = "Luis Actualizado", Email = "luis@newmail.com" });

        // Eliminar
        await repo.DeleteAsync(1);
        ~~~

## El siguiente paso natural: el Service
- Es la capara que usa el repositorio y aplica reglas de negocio
    - Comprobar si el email ya existe antes de guardar
    - Validar que el usuario tenga datos correctos
    - Combinar datos de varios repositorios
