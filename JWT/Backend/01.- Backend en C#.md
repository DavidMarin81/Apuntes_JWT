# Backend en C#

## Task y programación asíncrona
- Un `Task` representa una operación que se ejecuta en segundo plano y devuelve un resultado en el futuro
    - `Task` = operación asincrónica sin valor de retorno
    - `Task<T>` = operación asincrónica que devuelve un valor de tipo `T`
- Ejemplo
    ~~~csharp 
    async Task<int> CalcularAsync()
    {
        await Task.Delay(1000); // simula 1 segundo de trabajo
        return 42;
    }
    ~~~
- Y se usa así
    ~~~csharp
    int resultado = await CalcularAsync();
    ~~~

- ¿Por qué `Task<bool>` o `Task<User>`?
    - Cuando defines un método asincrónico que devuelve un valor (por ejemplo, un usuario o si la operación tuvo éxito):
        ~~~csharp
        public async Task<bool> DeleteUserAsync(int id)
        ~~~
    - Significa que el método devolverá un `bool`, pero envuelto en una tarea asincrónica
    - Cuando lo llames desde otro método `async`, usarás `await` para esperar el resultado:
        ~~~csharp
        bool deleted = await DeleteUserAsync(1);
        ~~~~ 

## IActionResult y controladores
- En ASP.NET Core, los controladores devuelven respuestas HTTP.
- El tipo base para eso es `IActionResult`
- ¿Qué es `IActionResult'?
    - Es una interfaz que representa una respuesta HTTP genérica
    - Tu controlador puede devolver:
        - `Ok(object)` -> 200 Ok con datos
        - `NotFound()` -> 404
        - `BadRequest()` -> 400
        - `NoContent()` -> 204
        - `CreatedAction(...)` -> 201 con ubicación del recurso
    - Ejemplo
        ~~~csharp
        [HttpGet("{id}")]
        public async Task<IActionResult> GetUser(int id)
        {
            var user = await _service.GetUserAsync(id);

            if (user == null)
                return NotFound();

            return Ok(user);
        }
        ~~~ 
        - Aquí `Ok(user)` devuelve un objeto `OkObjectResult`, que implementa `IActionResult`
        - Eso permite devolver distintos tipos de respuestas bajo una misma interfaz

- Variables modernas
    - También puedes devolver directamente el tipo de datos:
        ~~~csharp
        public async Task<User?> GetUser(int id)
        ~~~
    - Pero normalmente se usa `IActionResult` (o `ActionResult<T>`) para más flexibilidad y control de los códigos HTTP
    - Ejemplo moderno:
        ~~~csharp
        public async Task<ActionResult<User>> GetUser(int id)
        {
            var user = await _service.GetUserAsync(id);
            return user is null ? NotFound() : Ok(user);
        }
        ~~~

## async / await
- `async` y `await` funcionan casi igual que en JavaScript, pero con tipado fuerte
    - `async` indica que el método contiene operaciones asincrónicas
    - `await` espera a que una `Task` termine
- Ejemplo
    ~~~csharp
    async Task<string> GetDataAsync()
    {
        await Task.Delay(1000);
        return "Hola mundo";
    }

    async Task Main()
    {
        string data = await GetDataAsync();
        Console.WriteLine(data);
    }
    ~~~

## Nullables y el operador ?
- Desde C# 8, las referencias no son nulas por defecto, lo que ayuda a evitar `NullReferenceException`
    ~~~csharp
    string? nombre = null; // puede ser nulo
    string apellido = "García"; // no puede ser nulo
    ~~~
- Y puedes usar el operador de coalescencia nula `??`
    ~~~csharp
    string resultado = nombre ?? "Sin nombre";
    // Si nombre es null, usa "Sin nombre"
    ~~~

## Extras útiles para backend
| Características | Ejemplo | Descripción |
|---------------|------------|------------|
`var`   | `var x = 18` | Inferencia de tipos en compilación
`record`| `public record UserDto(string Name, string Email)` | Tipo inmutable, ideal para DTOs
`using` | `using var conn = new SqlConnection(...) | Maneja automáticamente la liberación de recursos
`DateTime` / `DateOnly` | `DateTime.now()`| Manejo de fechas
`Guid` | `Guid.NewGuid() | Identificadores únicos
